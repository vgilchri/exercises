//import "Ben's reference ladder": xDBL , xADD , LADDER;
load "Ben's reference ladder";

// step 1: find a point G of order l 
// input: (montgomery coefficient A for curve E) and (order l) and (finite field p and k) and (number of points N) and (m=N/l), output: (G a point of order l on E in K) 
// assume inputs are well defined for the context

// regular point  finding

point_finding:= function(A, p, k, l, N, m)
//Checks
  error if (l-1 mod k eq 0), "k ne divise pas l-1";
  error if (k  gt 13), "k est trop grand";
  
  t1 := ClockCycles();

 // set base field
 // K:= GF(p,k);
 // R<x>:=PolynomialRing(K);

  K := FiniteField(p, k); // finite field of size p^k

  // Sample a random point
  E := EllipticCurve([0,K!A,0,K!1,0]);
  //m:= RngIntElt(N/l);
  P_l:=K!0;
  res:=0;
  while IsZero(P_l) do
  res:= res +1;
    P:=Random(E);
    x_P := [P[1],P[3]];
    P_l:= LADDER(A,m,x_P);
  end while;
  
  T:= ClockCycles() - t1;
  print "Clock cyles :",T,"nb itérations : ",res;
  
  return P_l;

end function;

// Optimized point finding

//The function delta returns the image of a point P in E by the endomorphism delta defined as the division of (X^k-1) and the kth cyclotomic polynomial

delta := function(P,E,k) 

  if (k in {2,3,5,7,11}) then
    frobenius := FrobeniusMap(E);
    R := frobenius(P) - P;
    return R;
    
  elif (k eq 4) then
    frobenius_2:= FrobeniusMap(E,2);
    R := frobenius_2(P) - P;
    return R;
    
  elif (k eq 6) then
    frobenius := FrobeniusMap(E);
    frobenius_3:= FrobeniusMap(E,3);
    R := (frobenius(P) + P)*(frobenius_3(P) - P);
    return R;
    
   elif (k eq 8) then
    frobenius_4:= FrobeniusMap(E,4);
    R := frobenius_4(P) - P;
    return R;
          
   elif (k eq 9) then
    frobenius_3:= FrobeniusMap(E,3);
    R := frobenius_3(P) - P;
    return R;
    
   elif (k eq 10) then
    frobenius := FrobeniusMap(E);
    frobenius_5:= FrobeniusMap(E,5);
    R := (frobenius(P) + P)*(frobenius_5(P) - P);
    return R;
   
   elif (k eq 12) then
    frobenius_2:= FrobeniusMap(E,2);
    frobenius_6:= FrobeniusMap(E,6);
    R := (frobenius_2(P) + P)*(frobenius_6(P) - P);
    return R;
  end if;
 end function;
         
optimized_point_finding:= function(A, p, k, l, Nratio,m)
 //Checks
 error if (l-1 mod k eq 0), "k ne divise pas l-1";
 error if (k  gt 13), "k est trop grand";
  
 t1 := ClockCycles();
 

 // set base field
 // K:= GF(p,k);
 // R<x>:=PolynomialRing(K);

  K := FiniteField(p, k); // finite field of size p^k

  // Sample a random point
  E := EllipticCurve([0,K!A,0,K!1,0]);
  P_l:=K!0;
  res:=0;
  while IsZero(P_l) do
    res:=res+1;
    P:=Random(E);
    P:= delta(P,E,k);
    x_P := [P[1],P[3]];
    P_l:= LADDER(A,m,x_P);
  end while;
  
  T:= ClockCycles() - t1;
  print "Clock cyles :",T,"nb itérations : ",res;
  
  return P_l;

end function;
   
      

