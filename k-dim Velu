load "Ben's reference ladder";

// step 1: find a point G of order l 
// input: (montgomery coefficient A for curve E) and (order l) and (finite field p and k) and (number of points N) and (m=N/l), output: (G a point of order l on E in K) 
// assume inputs are well defined for the context

// regular point  finding

point_finding:= function(A, p, k, l, N, m)
//Checks
  error if (l-1 mod k eq 0), "k ne divise pas l-1";
  error if (k  gt 13), "k est trop grand";
  
  t1 := ClockCycles();

 // set base field
 // K:= GF(p,k);
 // R<x>:=PolynomialRing(K);

  K := FiniteField(p, k); // finite field of size p^k

  // Sample a random point
  E := EllipticCurve([0,K!A,0,K!1,0]);
  //m:= RngIntElt(N/l);
  P_l:=K!0;
  res:=0;
  while IsZero(P_l) do
  res:= res +1;
    P:=Random(E);
    x_P := [P[1],P[3]];
    P_l:= LADDER(A,m,x_P);
  end while;
  
  T:= ClockCycles() - t1;
  print "Clock cyles :",T,"\nNb itérations : ",res;
  
  return P_l;

end function;

// Optimized point finding

//The function delta returns the image of a point P in E by the endomorphism delta defined as the division of (X^k-1) and the kth cyclotomic polynomial

delta := function(P,E,k) 

  if (k in {2,3,5,7,11}) then
    frobenius := FrobeniusMap(E);
    R := frobenius(P) - P;
    return R;
    
  elif (k eq 4) then
    frobenius_2:= FrobeniusMap(E,2);
    R := frobenius_2(P) - P;
    return R;
    
  elif (k eq 6) then
    frobenius := FrobeniusMap(E);
    frobenius_3:= FrobeniusMap(E,3);
    res:=(frobenius_3(P) - P);
    R := (frobenius(res) + res);
    return R;
    
   elif (k eq 8) then
    frobenius_4:= FrobeniusMap(E,4);
    R := frobenius_4(P) - P;
    return R;
          
   elif (k eq 9) then
    frobenius_3:= FrobeniusMap(E,3);
    R := frobenius_3(P) - P;
    return R;
    
   elif (k eq 10) then
    frobenius := FrobeniusMap(E);
    frobenius_5:= FrobeniusMap(E,5);
    res:=(frobenius_5(P) - P);
    R := (frobenius(res) + res);
    return R;
   
   elif (k eq 12) then
    frobenius_2:= FrobeniusMap(E,2);
    frobenius_6:= FrobeniusMap(E,6);
    res:=(frobenius_6(P) - P);
    R := (frobenius_2(res) + res);
    return R;
  end if;
 end function;
         
// input: (montgomery coefficient A for curve E) and (order l) and (finite field p and k) and (number of points Nratio=N/N1) and (m=Nratio/l), output: (G a point of order l on E in K) 
// assume inputs are well defined for the context
         
         
optimized_point_finding:= function(A, p, k, l, Nratio,m)
 //Checks
 error if (l-1 mod k eq 0), "k ne divise pas l-1";
 error if (k  gt 13), "k est trop grand";
  
 t1 := ClockCycles();
 

 // set base field
 // K:= GF(p,k);
 // R<x>:=PolynomialRing(K);

  K := FiniteField(p, k); // finite field of size p^k

  // Sample a random point
  E := EllipticCurve([0,K!A,0,K!1,0]);
  P_l:=K!0;
  res:=0;
  while IsZero(P_l) do
    res:=res+1;
    P:=Random(E);
    P:= delta(P,E,k);
    x_P := [P[1],P[3]];
    P_l:= LADDER(A,m,x_P);
  end while;
  
  T:= ClockCycles() - t1;
  print "Clock cyles :",T,"\nNb itérations : ",res;
  
  return P_l;

end function;
 
 
 // compute minimal polynomial using gaussian elimination 
 // given g=x_G, p, k (where G is in the k^th extension of F_p)
 gauss_min_poly:= function(g, p,k)
  // set base field to be F_{q^k}, make sequence to store coeff. matrix rows
  F<e>:= GF(p,k);
  // put coefficient vectors of g^i into a matrix
  M:= Matrix([ElementToSequence(g^i): i in [0..k]]);
  "matrix is";
  M;
  // solve matrix 
  // W:= Vector(F, Insert(Eltseq(F!0),k+1,F!0));
  V:=Eltseq(Basis(Kernel(M)));
  "solution is:";
  // output solution, normalizing by making first value one, this is the min. poly. 
  if not(V[k+1] eq 0) and not(V[k+1] eq 1) then
    n:= V[k+1];
    for j in [1..k+1] do V[j] /:= n; end for;
  //  j:=1;
  //  while j lt k+1 do
  //    V[j] /:= n;
  //    j+:=1;
  // end while;
  end if;
  return V;
 end function;

test_gauss:= function()
  E:= GF(11,4);
  a:= Random(E);
  "test element is:";
  a;
  A:= gauss_min_poly(a, 11, 4);
  A;
  "magma's minimal polynomial is:";
  return MinimalPolynomial(a);
end function;


