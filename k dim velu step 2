# THIS IS SAGE CODE, NOT MAGMA

def find_eigen(ell, k, gen, p):
    # determines which scalar frobenius is acting as over the subgroup generated by gen
    # ell (int) is the order of gen (point), k (int) is the extension field size in which gen is, 
    # p (int) is the characteristic of the field
    
    # this set will store candidates
    order_k_elts = set()
    
    # checks for elements of order k
    for i in range(ell):
        if (i**k % ell == 0) and (i not in order_k_elts):
            subgrp = set()
            for j in range(k):
                subgrp.add(i**j % ell)
            if len(subgrp) == k:
                order_k_elts.update(subgrp)
    
    # if there is only one order k subgroup, we can choose any of these as the eigenvalue
    if len(order_k_elts) == k:
        return order_k_elts.popitem()
    # otherwise we check which one works by actually computing the frobenius and checking which scalar
    # multiplication it matches
    # how to make this loop more efficient?
    else:
        frob_x,frob_y = gen[0]**p,gen[1]**p
        for s in order_k_elts:
            # need to have that projective point is normalized, i.e. z-value is 1
            check = s*gen
            if check[0]==frob_x and check[1]==frob_y:
                return s
        
    return "search failed"
            

def orbit_gens(lam, ell,k):
    # takes the frobenius eigenvalue := lam and outputs which scalar 
    # multiples of a point will generate all the relevant galois orbits
    # all arithmetic is done over F_\ell
    
    # this set will store the generators of the orbits
    tl = set()
    
    # this set will store all the values in the orbits we've computed
    Tl = set()
    
    # we want a generator for every orbit up to negation,
    # so for each value from 1 to ell/2, we check if its already included in an orbit
    # if so we move on, if not we add it to tl and compute what its orbit is
    for i in range(1, int(ell/2 +1)):
        if (i not in Tl) and ((-1*i % ell) not in Tl):
            tl.add(i)
            for j in range(k):
                Tl.add(i*(lam**j) % ell)
                
    return tl

def compute_gens(gen,tl):
    # compute the scalar multiples of gen (elliptic curve point) denoted in tl (set)
    # for now we use the naive approach, needs to be optimized
    
    # here we store the generators of the galois orbits (scalar multiples of gen) in a set
    galois_gens = set()
    
    for s in tl:
        galois_gens.add(s*gen)
    
    return galois_gens
    
    
def step2(gen,ell,k,p,alpha):
    # computing the kernel polynomial
    # gen (point) is a point of order ell (int), k (int) is the size of the field extension, 
    # p (int) is the characteristic of the field of definition
    # alpha (int) is the value at which you want to compute the kernel polynomial, and is in F_p
    
    # find the eigenvalue of frobenius
    lam = find_eigen(ell, k, gen, p)
    
    # find which multiples of gen will generate the galois orbits, up to negation
    tl = orbit_gens(lam, ell,k)
    
    # compute the generators (points) of the galois orbits
    galois_gens = compute_gens(gen,tl)
    
    # compute the kernel polynomials 
    result = 1
    for s in galois_gens:
        result*=(alpha-s[0]) # the generators need to be normalized, i.e. have the z-value being 1
    
    # compute the exponent we need to apply to get the conjugate values in the galois orbits
    expo = 0
    for i in range(k):
        expo+= p**i
    
    return result**expo
    
